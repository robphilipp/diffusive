<!DOCTYPE html>
<html lang=en xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset=utf-8>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Diffusive programming highlights">
    <meta name="author" content="Robert Philipp">

    <link rel="stylesheet" type="text/css" href="themes/jquery-ui-1.9.2.custom.css">

    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shCore.css" />
    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shThemeEclipse.css" />

    <!-- Le styles -->
    <link href="scripts/bootstrap/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
        body {
            position: relative;
            padding-top: 81px;
            padding-bottom: 20px;
        }
        div.sidebar-nav {
            background: white;
            border: none;
            padding: 5px 0;
        }
        ul.header-nav-bar {
            padding-left: 5px;
            padding-top: 35px;
        }
    </style>
    <link href="scripts/bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="diffusive.css"/>

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="scripts/jquery-1.8.3.js"></script>
    <script src="scripts/ui/jquery-ui-1.9.2.custom.js"></script>

    <!-- Code Syntax Highlighting -->
    <script src="scripts/syntax_highlight/shCore.js"></script>
    <script src="scripts/syntax_highlight/shBrushJava.js"></script>

    <!-- Twitter bootstrap -->
    <script src="scripts/bootstrap/js/bootstrap.js"></script>

    <script src="scripts/toc-creator.js"></script>
    <script src="scripts/scroll-adjust.js"></script>
    <script src="scripts/setup.js"></script>
    <script>
        $(document).ready( function() {

            $(function() {
                $( "#principles-accordion, #patterns-accordion" ).accordion( {
                    autoHeight: false,
                    header: "h3",
                    collapsible: true,
                    active: false
                } );
                $( "#whats-new-accordion" ).accordion( { autoHeight: false } );
            });

            setup();
        }, false );
    </script>

    <title>Overview of Diffusive</title>
</head>

<body>


<nav class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container-fluid">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="brand" href="#"><img src="images/web_banner.png"></a>
            <div class="nav-collapse collapse">
                <ul class="nav header-nav-bar">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="quick_start.html" target="tab">Quick Start</a></li>
                    <li><a href="javadoc/index.html" target="tab">Java Docs</a></li>
                    <li><a href="https://github.com/robphilipp/diffusive" target="tab">Code (git)</a></li>
                    <li><a href="downloads.html" target="tab">Downloads</a></li>
                    <li><a href="https://github.com/robphilipp/diffusive/wiki" target="tab">Wiki</a></li>
                    <li><a href="https://github.com/robphilipp/diffusive/issues" target="tab">Tickets</a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </div>
</nav>

<div class="container-fluid">
    <div class="row-fluid">

        <div class="span3">
            <div class="well sidebar-nav">
                <!-- toc-creator will add the list of contents here -->
            </div>
        </div>

        <div class="span9">
            <h2 id="overview" class="no-show"><a href="#overview" class="scroll-offset">Diffusive</a></h2>
            <p>The goal of <em>diffusive programming</em> is make distributed computing easier--from design to development
                to troubleshooting to deployment. Diffusive achieves this by adhering to a set of principles
                designed to make the development of distributed applications more natural. Largely <em>diffusive</em> achieves
                this by making it easy to distribute <strong>any</strong> method, honoring the execution ordering defined
                in your code, and providing a natural load balancing mechanism by diffusing work throughout the
                diffuser network.</p>

            <!--

                Principles of Diffusive Programming

             -->
            <h2 id="principles_of_diffusive_programming"><a href="#overview" class="scroll-offset">Diffusive Principles</a></h2>

            <!--
                The Principles
             -->
            <div id="principles-accordion" class="my-accordion">
                <!-- marking -->
                <h3>marking</h3>
                <div>
                    <p class="key-point">A method can be marked for remote execution. The act of <em>marking</em>, alone, is
                        sufficient and necessary for a method to be executed on a remote location and have the results returned.</p>

                    <p><span class="label label-info">Definition</span>
                        A <b>diffusive method</b> is a method that has been <em>marked</em>.
                    </p>

                    <p><em>Diffusive programming</em> allows the execution of individual methods to be distributed. <em>Marking</em> a
                        method is the act of specifying that a specific method is to be distributed. How a method is <em>marked</em> is
                        up to the implementation of this principle. However, this principle does state that the act of <em>marking</em> a
                        method is necessary and sufficient for the method to be distributed. This means that <em>any</em> method can be
                        marked, and, therefore, executed, regardless of its name, parameters, or return type. This is a departure from
                        many typical task-orient approaches that require the implementation of task interfaces, where the method to be
                        executed has a defined signature (and return type).</p>

                    <p>The way a method is marked, to become a <em>diffusive</em> method, depends on the implementation of this principle.
                        For example, the reference implementation written in Java currently uses the <code>@Diffusive</code> annotation
                        to mark methods. However, it
                        could just as easily allow the fully qualified method names to be specified in a configuration file instead.</p>
                </div>

                <!-- location hiding -->
                <h3>location hiding</h3>
                <div>
                    <p class="key-point">Code calling a <em>diffusive</em> method does not, and can not, know on which
                        resource that method was executed. This helps keep code <em>cohesive</em> by removing distribution logic
                        from the application.</p>
                    <p><span class="label label-info">Definition</span>
                        A <b>diffuser</b> is what executes a <em>diffusive</em> method.</p>

                    <p>
                        <span class="label label-info">Definition</span>
                        A <b>diffused method</b> is a <em>diffusive</em> method that was
                        executed by a <em>diffuser</em>.</p>

                    <p><em>Marking</em> a method tells the diffusive framework that that method is to be executed in a distributed manner.
                        But it is the principle of <em>location hiding</em> that places the requirement that any code calling a diffusive method
                        does not know, or need to know, where that method is executed. Removing the responsibility of knowing or having to deal
                        with the consequences of where the method is executed relieves the calling code of any responsibility regarding
                        distribution. And this allows the application code to remain cohesive. It also means that the same code can be called
                        in a distributed manner, or to run completely locally with any change to the application logic.</p>

                    <p>In typical distributed systems, the distribution logic must be called directly from the application code. This may
                        occur by calling low level application programming interfaces (API) such as in MPI, or writing task classes that implement
                        interfaces defined by the distribution framework, and then modifying application code to deliver these tasks to the
                        middleware.</p>

                    <p>Location hiding allows code to be endowed with its execution logic, and that execution logic is then automatically
                        mirrored, but in a distributed manner, simply by marking the method(s). When this is coupled with the next principle,
                        <em>generic computation</em>, we have a powerful and simple mechanism to distribute computation.</p>

                </div>

                <!-- failure resolution -->
                <h3>best-efforts failure resolution</h3>
                <div>
                    <p class="key-point">A <em>diffuser</em> will attempt to recover from a
                        <em>diffusive failure</em>. If the <em>diffuser</em> is unable to recover, it will transfer error
                        handling to a specified handler or report the error as a local error.</p>
                    <p><span class="label label-info">Definition</span>
                        A <b>diffusive failure</b> is a the failure of a remote
                        <em>diffuser</em> to execute a <em>diffusive</em> method, or the loss of connectivity to a remote
                        <em>diffuser</em>.</p>

                    <p>A task that is called and executed completely within a local address space (for example, code running
                        entirely in one process). may fail to return a result. The failure may occur because an input or logic error, and
                        in this case, it may be possible to trap and handle the error condition. In other cases, the failure may occur
                        because of an unanticipated bug or because the server crashed. Under
                        these conditions it may not be possible to trap and handle the error condition, and the entire application may
                        crash or become unresponsive. In both scenarios, however, the fact that there was a failure is known because it due to
                        either the code trapping the error, or the user because the application crashed.</p>

                    <p>The situation may be quite different when a task is called from one address space and executed in another.
                        For example, suppose the application-attached diffuser diffuses a method to a remote diffuser. Now suppose further
                        that the task fails to execute because of an input or logic error. If the remote diffuser traps the error, it could
                        return an error condition which is return, and again trapped by the application-attached diffuser, and handled as in
                        the non-distributed case. However, suppose instead that the input or logic error isn't trapped, or if there is a
                        bug that causes the task to crash, or if the server crashes, or if the network connection goes down. In this case,
                        the application-attached diffuser waits for the result, but doesn't receive one. Yet, the application-attached diffuser
                        doesn't know if the task is still executing, or if there was a failure.</p>

                    <p>The <em>best efforts failure resolution</em> principle requires that the application doesn't see a difference between
                        a purely local and a distributed failure. The diffuser making the request is expected to perform its best to recover
                        from a <em>diffusive failure</em>, and if it can't, then it reports the error. For example, diffusers could provide a
                        status service that responds if the diffuser is running and accessible. If the requesting diffuser finds that the status
                        of the remote server is down, then it diffuses the method to a different diffuser. It may attempt to send the task to a
                        different diffuser a configured-number of times before giving up and reporting an error.</p>

                </div>

                <!-- generic computation engine -->
                <h3>generic computation</h3>
                <div>
                    <p class="key-point">Any <em>diffusive</em> method can be executed by any <em>diffuser</em>. A <em>diffuser</em> need not
                        be configured with resources prior to the request to execute a method.</p>

                    <p>The principle of <em>generic computation</em> provides that any method can be executed on a <em>diffuser</em>
                        without out the need to deploy the resource needed to execute that diffused method. Simply put, the shared object
                        libraries or classes don't need to be deployed to the remote server prior to making the request. Each <em>diffuser</em>
                        must contain a mechanism for providing resources to remote locations and for loading resources from a remote location.</p>

                    <p>In typical distributed computing, required resources must be deployed to the remote servers prior to requesting remote
                        execution of a specific task. Diffusive programming removes this restriction by requiring that the mechanism which
                        distributes the method execution also provides a capability to deliver the required resources to execute the method.</p>

                    <p>Note that, however, this does not prevent users from deploying resources to a common location from which they can be
                        obtained at run-time. Under certain deployment scenarios, it may be desirable to have such a common location to provide a
                        centralized control over the versions. But even in this case, the resources need only be deployed to the one common area.</p>

                </div>

                <!-- indistinguishablity -->
                <h3>indistinguishability</h3>
                <div>
                    <p class="key-point">A <em>diffuser</em> is responsible for executing any <em>diffusive</em> method, and it is also responsible
                    for <em>diffusing</em> methods to other <em>diffusers</em>. This implies that a <em>diffuser</em> must be
                    able to act both as a client and and as a server.</p>

                    <p>The principle of <em>indistinguishability</em> means that a <em>diffuser</em> must be able to receive requests to
                        execute, and at the same time be able to <em>diffuse</em> (forward) those requests to another <em>diffuser</em>. In other
                        words, there isn't such a thing as a client diffuser and a server diffuser: they are one and the same.</p>

                    <p>The <em>generic computation</em> principle alluded to this principle of <em>indistinguishability</em>. The generic
                        computation principle states that a diffuser must be able to load resources from a remote diffusers, <b>and</b> at the
                        same time must be able to provide resources to a remote diffuser.</p>

                </div>

                <!-- open topology -->
                <h3>open topology</h3>
                <div>
                    <p class="key-point"><em>Diffusers</em> can be connected in any topology that can represented as a directed graph. Each node
                    in the directed graph represents a <em>diffuser</em>. Each directed edge represents a connection from one
                    <em>diffuser</em> to another. The direction of the edge represents the direction of the <em>diffusion</em>.
                    And, each <em>diffuser</em> may contains connections to a set of other <em>diffusers</em>.</p>

                    <p><span class="label label-info">Definition</span>
                        A <b>diffuser network</b> is a set of connected <em>diffusers</em>.</p>

                    <p><span class="label label-info">Definition</span>
                        Suppose we have two <em>diffusers</em>, <b><em>A</em></b> and <b><em>B</em></b>. We say
                        that <b><em>B</em></b> is an <b>end-point</b> of <b><em>A</em></b>, if <b><em>A</em></b> <em>diffuses</em> methods to
                        <b><em>B</em></b>.</p>

                    <p>The <em>open topology</em> principle, coupled with the <em>indistinguishability</em> principle, requires that it is
                        possible to create networks of <em>diffusers</em>, called <em>diffuser networks</em>, in any topology that can be
                        represented as a directed graph. Each node in the directed graph represents a <em>diffuser</em>, and each (directed)
                        edge connects that <em>diffuser</em> to an <em>end-point</em>, which is another <em>diffuser</em>. Any network that
                        can be represented by a directed graph can be constructed.</p>

                    <p>This principle allows the construction of networks tailored to solve specific or general problems, networks that
                        can naturally learn/discover an optimal configuration for performing certain types of tasks, or networks that contain
                        sufficient redundancy to provide execution within required timelines. The <a href="#diffusion_patterns" class="scroll-offset">diffusion patterns section</a>,
                        describes a few possible network topologies (patterns) that are designed to solve specific problems.</p>

                </div>
            </div>


            <!--

                Diffusion Patterns

             -->
            <h2 id="diffusion_patterns"><a href="#overview" class="scroll-offset">Diffusion Patterns</a></h2>
            <p>The <em>open topology</em> principle gives rise to the notion of <em>diffusive patterns.</em> Diffusers
                can be connected together as a network where each diffuser executes or forwards work. The topology of
                a diffuser network and the strategies used for determining how work is distributed form a
                <strong>diffusion pattern</strong>. Diffusion patterns provide templates that can be used to solve
                various types of problems.</p>

            <div id="patterns-accordion" class="my-accordion">
                <!-- single layered -->
                <h3>single layered</h3>
                <div class="container-fluid">
                    <div class="row-fluid">
                        <div class="span2">
                        <p class="image" id="figure_single_layered" class="scroll-offset">
                            <img src="images/single_layer.png" title="Single Layer Diffuser Network Topology"/></p>
                        </div>
                        <div class="span10">
                            <p>Many distributed computing tasks can simply be split up into independent units of work, sent out
                                to a compute node, and have the results processed in the application. In such cases, a simple
                                single-layered diffuser pattern may suffice.</p>
                            <p>In the single-layered pattern is the application-attached diffuser is connected to a set of remote
                                diffusers. The remote diffusers only execute code, but do not forward work, even if their load
                                is high, or even if they make a call to another diffusive method.</p>
                        </div>
                    </div>
                    <div class="row-fluid">
                        <div class="span2">
                        <p class="image" id="figure_single_layered_connected" class="scroll-offset">
                            <img src="images/single_layer_connected.png" title="Single Layer Diffuser Network Topology"/></p>
                        </div>
                        <div class="span10">
                            <p>A variation of this pattern that provides a natural load balancing mechanism is to connect the
                                each remote diffuser to one or more of the other remote diffusers. In this case, when a diffuser
                                has a high load it can forward it to another diffuser, which can execute the work or forward
                                the work again.</p>
                            <p>In these <figures></figures>, the blue circles are the remote <em>diffusers</em> and the red circle is the
                                application-attached diffuser.</p>
                        </div>
                    </div>
                </div>

                <!-- multi layered -->
                <h3>multi layered</h3>
                <div class="container-fluid">
                    <div class="row-fluid">
                        <div class="span2">
                            <p class="image" id="figure_multi_layered">
                                <img src="images/multi_layer.png" title="Multi-Layer Diffuser Network Topologies"/>
                            </p>
                        </div>
                        <div class="span10">
                            <p>A natural extension of the single-layered diffuser pattern is a multi-layered diffuser pattern.
                                Applications that perform nested diffusion--a diffused method calling other diffused methods--benefit
                                from this type of topology.</p>
                            <p>Nested diffusion is a natural consequence for problems where individual tasks are distributed can
                                be represented in a hierarchical pattern. For example if you have groups of tasks that return
                                results to the application for further, and potentially complex processing, causing the application
                                to become a bottleneck. In these cases, you can distribute individual groups of work to the
                                "first layer" of remote nodes. These remote nodes then distribute individual tasks to a "second
                                layer" of remote nodes. When the nodes in the "second layer" complete their tasks, the nodes
                                in the "first layer"  process the results and return them to the application. In this way, the
                                application is no longer the bottleneck.</p>
                        </div>
                    </div>
                </div>

                <!-- redundant -->
                <h3>redundant</h3>
                <div>
                    <p>In distributed computing it is not uncommon that a task fails to complete. A compute node may have crashed or
                        lost network connectivity with the collective. Or some mysterious set of events placed the execution of the task
                        in an unusual, never-to-be-repeated-until-a-demo state that prevented its completion. In cases where the completion
                        of each individual task is required to occur at least once in a given time period, we can send redundant tasks to
                        different compute nodes, and use the first result from each individual task to come back.</p>
                    <p>Diffusive can be configured to send redundant tasks.</p>
                </div>

                <!-- connected -->
                <h3>connected</h3>
                <div class="container-fluid">
                    <div class="row-fluid">
                        <div class="span2">
                            <p class="image" id="connected">
                                <img src="images/connected.png" title="Connected Diffuser Network Topologies"/>
                            </p>
                        </div>
                        <div class="span10">
                            <p>The connected pattern provides a general purpose diffuser network that makes a flexible topology
                                available on which applications can diffuse work. Having all--or most--diffusers connected to each other,
                                provides natural load balancing, allows nested diffusion, and recursive diffusion.</p>
                        </div>
                    </div>
                </div>

                <!-- learning -->
                <h3>learning</h3>
                <div>
                    <p>The connected pattern provides a general purpose diffuser network providing a flexible topology on
                        which applications can diffuse work. Implicit in this pattern is that the <code>Strategy</code> used
                        to diffuse work chooses remote diffusers with fixed probabilities. But since hardware may differ
                        across the diffuser network, these probabilities can be adjusted to send work to more capable
                        hardware with higher probability.</p>
                    <p>In cases where similar types of processes are run repeatedly, these probabilities can be adjusted
                        through an algorithm that sets the probabilities such that the overall execution time is minimized.</p>
                </div>

                <!-- recursive -->
                <h3>recursive</h3>
                <div class="container-fluid">
                    <div class="row-fluid">
                        <div class="span2">
                            <p class="image" id="recursive">
                                <img src="images/recursive.png" title="Recursive Diffuser Network Topologies"/>
                            </p>
                        </div>
                        <div class="span10">
                            <p>Distributed recursive algorithms are quite straightforward to implement in diffusive. As
                                in "normal" recursion, a method can call itself. When the method is a diffusive method
                                (i.e. a method marked with <code>@Diffusive</code>) it will diffuse that method call
                                forward to a remote diffuser. In this case, the diffuser network topology should allow
                                deep recursion, which means setting up loops.</p>
                        </div>
                    </div>
                </div>

            </div>

            <div class="alert">
                <strong>Important Point: </strong>A diffuser network is a not a physical network. Connecting one diffuser to another means
                configuring the diffusers' end-points.
            </div>

            <!--

                Reference Implementation

             -->
            <h2 id="reference_implementation"><a href="#overview" class="scroll-offset">Reference Implementation</a></h2>
            <p>The <em>Diffusive</em> reference implementation is a Java-based framework that implements the <em>diffusive</em>
            principles. Aspects of <em>Diffusive</em> are specific to its implementation, and could be implemented in other ways.
            For example, in <em>Diffusive</em> methods are <em>marked</em> through the use of annotations. In particular, a
            <em>diffusive</em> method is annotated with <code>@Diffusive</code>. However, it would have been possible to allow
            methods to be marked through a configuration file that holds a list of <em>markers</em> represented by their
            fully qualified method names. (For example, the fully qualified method name could be represented by the
            fully qualified class name with the method name appended with a &quot;.&quot;, such as
            <code>org.myapp.calc.PriceCalc.calculate</code>.). These aspects only change the specifics of how a
            <em>diffusive</em> framework implements the principles, but not how it behaves.</p>

            <p>In the next sections I discuss how <em>Diffusive</em> framework implements the five diffusive principles.</p>

            <!--
                Marking and Diffusing
             -->
            <h3 id="marking_and_diffusing"><a href="#overview" class="scroll-offset">Marking and Diffusing</a></h3>
            <p>The diffusive principle, <em>marking</em>, requires that a method is somehow identified as a
            <em>diffusive method</em>. It further requires that <em>marking</em> a method is both sufficient and necessary for
            a method to be diffused. The <em>location hiding</em> principle takes it a step further by requiring that any
            application method calling a diffusive (marked) method does not, and can not, know where that method is being executed.</p>

            <!--
                Launching and Instrumentation
             -->
            <h4 id="launching_and_instrumentation"><a href="#overview" class="scroll-offset">Launching and Instrumenting</a></h4>
            <p><em>Diffusive</em> accomplishes this through a combination of annotations and load-time byte-code engineering.
            The annotations are simple: any method that is to be diffused is annotated with <code>@Diffusive</code>. This signals
            the class-loader that any calls to this method should be replaced with a call to a pre-configured diffuser. In this way, the
            marked method calls get handed to the diffuser, along with the methods parameter types and values, then name of the class in
            which the method resides, and the method's return type. To accomplish this <em>Diffusive</em> uses the byte-code
            engineering framework <a href="http://www.jboss.org/javassist/">Javassist</a>. (Some have pointed out that another
            approach would have been to use aspect-oriented programming frameworks such as AspectJ. However, the compact
            <a href="http://www.jboss.org/javassist/">Javassist</a> framework provides everything <em>Diffusive</em> needs.)</p>

            <p>In order to replace marked methods during class-loading, the application classes must be loaded through the diffusive
            class loader (<code>DiffusiveLoader</code>). This is accomplished by using an application launcher, called the
            diffusive launcher (<code>DiffusiveLauncher</code>). The diffusive launcher accepts the name of the application's
            Java class, creates a diffusive class loader, and asks it to run the application. The diffusive loader reads the
            configuration items, sets up the application-attached diffuser to which marked method calls are diverted, and determines
            whether a class is loaded by the application's class loader and which are passed to the <a href="http://www.jboss.org/javassist/">Javassist</a>
            <code>Loader</code>.</p>

            <p class="image" id="figure_diffusive_launcher">
                <img src="images/diffusive_launcher.png" title="Launching an application in Diffusive"/>
            </p>

            <p>The above <a href="#figure_diffusive_launcher" class="scroll-offset">figure</a> illustrates launching an application in <em>Diffusive</em>.
            At the top of the figure is a box labeled &quot;Application&quot; which represents the unadulterated application. The light
            blue dot in that box represents a method call to the red dot. The red dot represents a <em>marked</em> method. The
            application passes through the launcher and into the loader. The <code>DiffusiveLoader</code> sets up the
            repository holding the default diffuser, reads the configuration items, creates an <em>application-attached</em> diffuser,
            and hands the application to the Javassist <code>Loader</code> to instrument the application. The tan box labeled
            &quot;Application&quot; in the lower-right hand side of the figure represents the instrumented, or modified, application.
            Notice that now, all the method calls to the <em>marked</em> method are diverted to the <em>application-attached</em>
            diffuser, which contains the required mechanism to execute that method. It is the application-attached diffuser, the
            green circle on the bottom left-hand side of the figure, that is responsible for distributing the method execution.
            It is important to point out that the original application code is untouched.</p>

            <!--
                Distributing
             -->
            <h4 id="distributing"><a href="#overview" class="scroll-offset">Distributing</a></h4>
            <p>The <em>application-attached</em> diffuser is responsible for distributing method calls to other diffusers, or
            depending on its configuration and load, executing the method itself. By default <em>Diffusive</em> uses a
            <em>RESTful</em> diffuser (<code>RestfulDiffuser</code>) that adheres to the <a href="http://jsr311.java.net">JSR-311</a>
            standard, and uses the <a href="http://jersey.java.net">Apache Jersey</a> implementation. Although <em>Diffusive</em>
            uses a RESTful diffuser by default, any diffuser implementation can be used to provide the required functionality.
            In fact, <em>Diffusive</em> also comes with a local diffuser that runs the code locally. (Using <em>Diffusive's</em> local
            diffuser directly is inefficient. Unless you are using the local diffuser for testing the diffusive framework through a
            local debugger, using the local diffuser directly means that you aren't diffusing the code. In which case, it doesn't
            make sense to use <em>Diffusive</em> in the first place. The local diffuser only exists because it is used by the RESTful
            diffuser when it executes a method locally rather than distribute it.)</p>

            <p>The RESTful diffuser must be configured with a set of <em>end-points</em> to which it can diffuse method execution.
            These end-points, themselves, must contain a RESTful diffuser. And the access to the diffuser must be accomplished
            through a some sort of a software server. <em>Diffusive</em> provides a RESTful diffuser server
            (<code>RestfulDiffuserServer</code>) that contains an <a href="http://grizzly.java.net">Apache Grizzly</a>
            web server configured to interact with a <a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html">JAX-RS</a>.
            web resource (<code>RestfulDiffuserManagerResource</code>).</p>

            <p>Within the context of the RESTful diffuser server, there is one RESTful diffuser for each diffusive method. In other
            words, each unique diffusive method signature has its own diffuser, accessible via the web resource
            (<code>RestfulDiffuserManagerResource</code>) through its uniform resource identifier (URI). Recall that a diffusive
            method signature contains the name of the containing class, the method name, the method's formal argument types, and the
            return type. This is different from a Java signature, which contains only the method name and the formal argument types.
            The web resource manages the creation, querying, calling, and deletion of its diffusers by responding to requests from the calling diffuser. And
            each diffuser is a resource with a unique address. For example, a new diffuser is created through an <b class="tt">HTTP POST</b>
            call containing the required information about the diffusive method signature. Obtaining information about a diffuser is
            accomplished through an <b class="tt">HTTP GET</b> call to its URI. To execute a method, an <b class="tt">HTTP POST</b> is called on the URI
            of the diffuser, passing along the information needed to execute the method. The execute method returns an ID (link) to
            the results resource, in line with the approach of <em>hypermedia as the engine of application state</em> (HATEOAS). The result can then be obtained
            through an <b class="tt">HTTP GET</b> call to the URI of that result, which blocks until the result is complete. Alternatively,
            the status of the result can be obtained through an <b class="tt">HTTP HEAD</b> call to the URI of the result, which is non-blocking,
            and returns an empty response if the result resource is not yet available. And, finally, a diffuser can be deleted through
            an <b class="tt">HTTP DELETE</b> call to its URI.</p>

            <p>To facilitate development, <em>Diffusive</em> provides a RESTful client (<code>RestfulDiffuserManagerClient</code>)
            that takes care of the underlining communication, serializing/deserializing, creating requests, and parsing responses. This
            client allows developers to deal only with Java objects.</p>

            <!--
                Distribution Strategy
             -->
            <h4 id="distribution_strategy"><a href="#overview" class="scroll-offset">Distribution Strategy</a></h4>
            <p>Diffusers decide how to distribute the method calls based on a strategy (<code>Strategy</code>). A
            <code>Strategy</code> simply returns a list of end-points when requested. In most cases, the list returned
            by the <code>Strategy</code> contains only one element. However, to allow for redundant diffuser networks,
            the <code>Strategy</code> interface allows the return of a list of end-points. <code>Strategy</code>
            implementations can take into account various aspects that affect the optimal distribution of method calls. For
            example, a <code>Strategy</code> implementation may take into account the load on its server, the number of
            diffusers executing, the number of threads available for execution, and weighting factors for individual end-points.</p>

            <!--
                Serialization
             -->
            <h4 id="serialization"><a href="#overview" class="scroll-offset">Serialization</a></h4>
            <p>In order to execute a method remotely, the remote execution environment needs certain information. Specifically,
            the execution environment needs:</p>
            <ul>
                <li>The state of the object against which the method call was made.</li>
                <li>All the arguments to the method.</li>
            </ul>

            <p>To transfer that information to the remote diffuser, across the network, they must be serialized. Likewise, once
            execution is completed, the return object must be serialized and returned to the original diffuser.</p>

            <p>When the remote execution environment receives these serialized objects, it must reconstruction them as Java objects.
            And to reconstruct serialized objects requires Java <code>Class</code> objects corresponding each of the
            serialized objects. The <code>Class</code> objects are effectively the templates used to reconstruct an object.
            In the section on <a href="#generic_computation" class="scroll-offset">generic computation</a>, we discuss how the remote environment gets
            access to these <code>Class</code> objects without the need to deploy them prior to execution.</p>

            <p><em>Diffusive</em> provides an interface, <code>Serializer</code>, that defines what a serializer must
            provide to <em>Diffusive</em>. Two key serialization implementations have been wrapped to conform to the
            <code>Serializer</code> interface: <code>ObjectSerializer</code> and
            <code>PersistenceSerializer</code>. The <code>ObjectSerializer</code> is Java's own serialization
            framework which requires that classes implement the <code>Serializable</code> interface. Using this
            serialization framework requires altering existing classes, that are to be serialized, if they don't implement
            <code>Serializable</code>. In some cases this may be acceptable. In other cases it may not be possible.</p>

            <p>The <code>PersistenceSerializer</code> wraps the <a href="http://freezedried.sourceforge.net">FreezeDry</a>
            persistence framework. <b>FreezeDry</b> does not require any classes to implement a FreezeDry-specific interface.
            In fact, FreezeDry can take any existing class (even those without no-arg constructors) and serialize them into XML,
            JSON, or key-value pairs. However, if the class is too complex, it may require some coding.</p>

            <!--
                Best-Efforts Failure Resolution
             -->
            <h3 id="best_efforts_failure_resolution"><a href="#overview" class="scroll-offset">Best-Efforts Failure Resolution</a></h3>
            <p>The <em>Diffusive</em> reference implementation uses the concept of a <code>Strategy</code> to determine
            to which diffuser a method is diffused. The current <code>Strategy</code> interface requires that a
            <code>Strategy</code> return a list of end-points to which the method can be diffused. An implementation of
            best-efforts failure resolution can be achieved by creating a RESTful diffuser that diffuses its method to the first
            end-point in the list, and if that fails to the next end-point, until the task completes, or until the diffuser runs
            out of end-points.</p>

            <!--
                Best-Efforts Failure Resolution
             -->
            <h3 id="generic_computation"><a href="#overview" class="scroll-offset">Generic Computation</a></h3>
            <p>The <em>Generic Computation</em> principle requires two that two conditions are met: that any method can be diffused;
            and, prior deployment of resources is not required. The first condition is met because of the <em>Marking</em>
            principle---any marked method can be diffused. The second condition is the focus of this section.</p>

            <p>As discussed in <a href="#serialization" class="scroll-offset">serialization section</a>, in order to transport objects across the network
            they must be serialized. This means that to execute a diffusive method remotely requires that the following objects
            must be serialized:</p>
            <ul>
                <li>The object containing the diffusive method.</li>
                <li>All objects referenced by the object containing the diffusive method.</li>
                <li>The objects passed to the diffusive method as arguments.</li>
                <li>All objects referenced by the objects passed to the diffusive method as arguments.</li>
            </ul>

            <p>Once these serialized objects are received by the remote diffuser, it needs to deserialize them back into objects.
            To deserialize any object requires that the class loader has loaded a <code>Class</code> object corresponding
            to that object (and any objects that object references). Usually, this is handled by deploying the class files
            (as jar or war files) to the remote servers executing the methods, and configuring their class paths to contain their
            location.</p>

            <p>The <em>Generic Computation</em> principle states that deployment of resources to the remote nodes does not need
            to occur <em>before</em> requesting the remote diffuser to execute a method. In practical terms, this principle
            requires that the remote diffuser contains a mechanism for loading classes from a remote source, and that a mechanism
            exists, preferably on the application-attached diffuser, that can provide serialized <code>Class</code> objects
            to the remote diffuser.</p>

            <p><em>Diffusive</em> provides a RESTful class loader (<code>RestfulClassLoader</code>) that can load classes
            from a corresponding RESTful web service. The <code>RestfulClassPathResource</code> is a (JSR-311) web resource,
            attached to the web service, that provides serialized <code>Class</code> objects to the requesting client (i.e. the
            <code>RestfulClassLoader</code>).</p>

            <p class="image" id="figure_diffusing">
                <img src="images/diffusing.png" title="Process of diffusing a method call"/>
            </p>

            <p>The above <a href="#diffusing" class="scroll-offset">figure</a> shows the process of creating, configuring, and executing a task using
            <em>Diffusive</em>. In this figure, the application requests that its <em>application-attached</em> diffuser, which
            is labeled as Diffuser 1 in the figure, execute the task labeled <code>Task</code>. In this scenario,
            Diffuser 1 decides to diffuse the task to one of its end-points, Remote Server A. If the remote server
            doesn't contain a diffuser that matches the diffusive method signature of <code>Task</code>, then, as shown in
            step 1 of the above <a href="#diffusing" class="scroll-offset">figure</a>, Diffuser 1 requests that Remote Server A create a diffuser
            with that signature, which is shown as Diffuser 2. In order to execute <code>Task</code>,
            Diffuser 2 needs to load the <code>Class</code> objects associated with <code>Task</code>.
            And because Diffuser 1 has those <code>Class</code> objects, it passes the URI corresponding to the
            web service that can provide those <code>Class</code> objects, along with its request to create
            Diffuser 2.</p>

            <p>As shown in step 2 of the above <a href="#diffusing" class="scroll-offset">figure</a>, Remote Server A then creates Diffuser 2
            and configures it with the class path information and other configuration items, and returns URI to Diffuser 2,
            the newly created diffuser. Diffuser 1 now requests that Diffuser 2 execute <code>Task</code>
            (step 3). As part of that request, Diffuser 1 passes all the required serialized object along with the execute
            request. Diffuser 2 receives that request, tries to deserialize the objects, but can't because it doesn't have
            access to the <code>Class</code> objects associated with <code>Task</code>. And so Diffuser 2
            initiates a call back to the class path URI requesting the <code>Class</code> objects (step 4).</p>

            <p>Diffuser 1 sends the serialized <code>Class</code> objects requested back to Diffuser 2
            (step 5), and Diffuser 2 loads the <code>Class</code> objects, which enables it to deserialized the
            objects associated with <code>Task</code>. Now Diffuser 2 is set up to execute the <code>Task</code>, w
            hich it does (step 6), and returns a result ID. The result ID is a URI to the result. When Diffuser 1 receives
            the result ID, it requests the result (step 7), which is a blocking call, and waits for the result response (step 8).
            When Diffuser 1 receives the results, it deserialized the result object and returns it the application (again,
            this is automatic through Javassist).</p>

            <p>There are a few noteworthy points.</p>
            <ul>
                <li>Once a diffuser is created, it can be reused, and it can be deleted.</li>
                <li>The remote class loading is managed through a RESTful class loader and web service, and is part of
                    <em>Diffusive</em> by default.
                </li>
                <li>When creating a remote diffuser, the class path URI does <em>not</em> need to be the URI pointing
                    back to the diffuser requesting the creating. In fact, it can be a common web service that contains a
                    pre-deployed set of class files and can serve them up. However, this reduces the generic computation
                    somewhat.
                </li>
            </ul>

            <!--
                Indistinguishability and Open Topology
             -->
            <h3 id="indistinguishability_and_open_topology"><a href="#overview" class="scroll-offset">Indistinguishability and Open Topology</a></h3>
            <p>In <em>Diffusive</em> all diffusers of a certain type are the same. And with the exception of the
            <em>application-attached</em> diffuser, all diffusers are managed the same way. The application-attached diffuser,
            as the name implies, is attached to the application through the diffusive launcher. Recall that the diffuser launcher
            is used to launch the application, and during the process of launching the application, the application is
            instrumented to divert calls to diffusive methods to the application-attached diffuser. It is the application-attached
            diffuser that diffuses (distributes) method calls to remote diffusers.</p>

            <p class="image" id="figure_restful_diffuser_server">
                <img src="images/restful_diffuser_server.png" title="RESTful Diffuser Server"/>
            </p>

            <p>Recall that in <em>Diffusive</em>, a remote diffuser is managed by RESTful diffuser server. A RESTful diffuser
            servers (<code>RestfulDiffuserServer</code>) act as servers to which methods can be diffused. The RESTful
            diffuser servers also act as clients when diffusing methods to other remote diffusers, or when other diffusers
            request <code>Class</code> objects from their class path. And therefore, all remote diffusers look alike.
            The above <a href="#restful_diffuser_server" class="scroll-offset">figure</a> shows the basic elements contained in a RESTful diffuser
            server and depicts a typical interaction. In this scenario, the <code>RestfulDiffuserServer</code> receives
            a request to execute a method (task). The <code>RestfulDiffuserServer</code>, a web server, forwards the
            request to the web resource, <code>RestfulDiffuserManagerResource</code>, (A JSR-311 web resource)
            which is bound to its <code>execute(...)</code> method. The execute method looks up the appropriate diffuser
            based on the diffuser method signature, which is part of the its URI, returns a response containing the result ID
            (a URI to the result resource) and then forwards the method to that diffuser.</p>

            <p>Each RESTful diffuser contains a <code>RestfulClassLoader</code> which loads a class using a RESTful web
            service. The <code>RestfulClassLoader</code> acts as a client to the <code>RestfulClassPathResource</code>,
            which serializes the request <code>Class</code> object and returns it. The RESTful class loader then
            deserializes the <code>Class</code> object and loads it. Notice that each <code>RestfulDiffuserServer</code>
            contains the <code>RestfulClassPathResource</code>.</p>

            <p>At this point, the diffuser can execute the method and return the result to the
            <code>RestfulDiffuserManagerResource</code>.</p>

            <p>Each diffuser contains a list of end-points to which it can diffuse code, a list of class paths from which it can
            load <code>Class</code> objects, a <code>Strategy</code> which determines how the end-points for
            executing the next task are selected, and a RESTful class loader to load class over the network. It is the fact that
            each diffuser server looks the same that makes each diffuser server a building block from which to construct arbitrary
            diffuser networks---as long as they can be represented by a directed graph.</p>

            <!--

                Future Work

             -->
            <h2 id="future_work"><a href="#overview" class="scroll-offset">Future Work</a></h2>
            <p>The current reference implementation is a work in progress. The main goal for creating a reference implementation
            was to prove that the concepts of \emph{diffusive programming} could be implemented, with an eye toward building a
            robust, secure, and accessible implementation. Given that, there are a number of items that need further exploration
            and development.</p>

            <ul>
                <li>Add best-efforts failure resolution to the RESTful diffuser.</li>
                <li>Provide additional deployment options (for example, into a servlet container).</li>
                <li>Create additional diffusers beside RESTful diffusers (for example, RMI diffusers).</li>
                <li>Create deployment and management tools that allow easy deployment of diffusive servers and allows starting
                    and stopping the diffusive server. Also, allows the management of the diffusers.</li>
            </ul>
        </div>
    </div>
</div>

<footer>
    <p>&copy; Robert Philipp 2012</p>
</footer>
</body>
</html>
