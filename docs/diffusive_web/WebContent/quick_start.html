<!DOCTYPE html>
<html lang=en>
<head>
	<meta charset=utf-8>
	<link rel="stylesheet" type="text/css" href="diffusive.css"/>

	<!-- Code Syntax Highlighting -->
    <script src="scripts/syntax_highlight/shCore.js"></script>
    <script src="scripts/syntax_highlight/shBrushJava.js"></script>
    <script src="scripts/syntax_highlight/shBrushXml.js"></script>

    <script src="scripts/toc-creator.js"></script>
    <script src="scripts/sizing.js"></script>

    <script src="scripts/jquery-1.8.2.js"></script>
    <script>
        var tocBounds = { minWidth: 100, maxWidth: 225, minHeight: 400, maxHeight: 400 };
        var articleBounds = { minWidth: 100, maxWidth: 775, minHeight: 400, maxHeight: 1000 };
        $(document).ready( function() {

            // syntax highlighting for the code
            SyntaxHighlighter.defaults['gutter'] = false;
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.all();

            // create the table of contents
            createToc( "Contents" );

            // adjust the article window size
            adjustSizes( tocBounds, articleBounds );
        }, false );

        window.onresize = function() {
            adjustSizes( tocBounds, articleBounds );
        };

    </script>


    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shCore.css" />
    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shThemeEclipse.css" />


    <title>Diffusive</title>
</head>

<body>

<header>
	<img src="images/web_banner.png">
</header>

<nav>
	<a href="index.html">Home</a>
	<a href="overview_guide.html">Overview</a>
	<a href="javadocs/index.html" target="tab">Java Docs</a>
	<a href="https://sourceforge.net/p/diffusive/code/" target="tab">Code (hg)</a>
	<a href="https://sourceforge.net/projects/diffusive/files/" target="tab">Downloads</a>
	<a href="https://sourceforge.net/p/diffusive/wiki/Home/" target="tab">Wiki</a>
	<a href="https://sourceforge.net/p/diffusive/tickets/" target="tab">Tickets</a>
	<a href="https://sourceforge.net/p/diffusive/discussion/" target="tab">Discussion</a>
</nav>

<article>
<!-- 

	Participate

 -->
<h2 id="participate"><a href="#participate">Participate</a></h2>
<p>The <b>Diffusive</b> reference implementation works, but is still in development. There are still a number of
items and features to be implemented for the base version. And there are a number of enhancements that ought to
be developed regarding deployment and management of the diffusive network. So if you find you like Diffusive, please
participate (contact: <a href="mailto:rob.philipp@gmail.com?Subject=Contributing%20to%20Diffusive">Rob Philipp</a>).</p>

<p>For a more complete description of diffusive programming and the reference implementation, please see the
<a href="overview_guide.html">the Overview</a> or download the 
<a href="https://sourceforge.net/projects/diffusive/files/diffusive_programming.pdf">Diffusive Programming</a> paper.</p>

<!-- 

	Getting Started

 -->
<h2 id="getting_started"><a href="#participate">Getting Started</a></h2>
<p>The next sections describe how to work with Diffusive in its current state. As Diffusive evolves, many of the
idiosyncrasies of the current state will be removed, and it will become much easier to work with and use. For now,
however, as I heard someone say: &quot;<em>it is what it is, and if it were different, it'd be different</em>&quot;.</p> 

<!-- 
	Idiosyncrasies of the Current State
 -->
<h3 id="current_state_idiosyncrasies"><a href="#participate">Idiosyncrasies of the Current State</a></h3>
<p>Given that Diffusive is still in development, there are a few items that are fine for development, but make it harder
for a user. As Diffusive progresses, these items will be cleaned up.</p>

<ul>
	<li id="configuration_idiosyncrasy">Diffusive uses a Java-based configuration to define its behavior and the topology of the network. The current
		Java-based configuration uses annotations (<b class="class">@DiffusiveConfiguration</b> and 
		<b class="class">@DiffusiveServerConfiguration</b>)) on configuration methods to configure various aspects
		of Diffusive. The next step is to modify the current configuration methods to read basic parameters from
		various sources, and then configure Diffusive based on those parameters. The next iteration will allow the
		user to name a Java source file that will be compiled and loaded and run to configure Diffusive.
	</li>
	<li>The current test classes are included in the distribution under the <b>tests</b> package. These test cases
		will be moved into a separate distribution. This becomes important when testing that classes are actually
		loaded across the network through the <b class="class">RestfulClassLoader</b>. Currently, for the distribution
		deployed as the server (as opposed to the application-attached diffuser) you must remove the test classes if
		you want them to be loaded over the network. And that is a cumbersome if you are deploying jar files, because
		then you need to two versions.
	</li>
</ul>

<!-- 
	Build Environment
 -->
<h3 id="build_environment"><a href="#participate">Build Environment</a></h3>

<!-- Minimum Requirements -->
<h4 id="minimim_requirements"><a href="#participate">Minimum Requirements</a></h4>
<p>Diffusive requires Java 7.</p>

<!-- External Dependencies -->
<h4 id="external_dependencies"><a href="#participate">External Dependencies</a></h4>
<dl>
	<!-- Javassist -->
	<dt>Javassist</dt>
	<dd>
		Javassist is a byte-code engineering library that is core to Diffusive. Recall that methods are diffused based
		on the annotation <b class="class">@Diffusive</b>. Javassist finds those annotations at class-load time and replaces
		all method calls to these annotated methods with a call to the diffuser instead.
		<ul>
			<li>javassist.jar</li>
		</ul>
	</dd>
	
	<!-- Jersey -->
	<dt>Jersey and Grizzly</dt>
	<dd>
		Diffusive uses REST to manage diffusers and communicate between them. Jersey is a JSR-311 (JAX-RS) implementation
		that provides convenient binding between the resource address and methods that handle them. And Grizzly is an 
		in process HTTP server and client that Diffusive uses for issuing and handling HTTP requests.
		<ul>
			<li>grizzly-framework-2.2.1.jar</li>
			<li>grizzly-http-2.2.1.jar</li>
			<li>grizzly-http-server-2.2.1.jar</li>
			<li>jersey-client-1.12.jar</li>
			<li>jersey-core-1.12.jar</li>
			<li>jersey-grizzly2-1.12.jar</li>
			<li>jersey-server-1.12.jar</li>
			<li>jsr311-api-1.1.1.jar</li>
		</ul>
	</dd>
	
	<!-- Abdera -->
	<dt>Abdera v1.1.2</dt>
	<dd>
		Diffusive uses REST to manage diffusers and communicate between them. The messages flying back and forth are
		Atom formated XML and Diffusive uses Abdera for creating and parsing the Atom messages.
		<ul>
			<li>abdera-core-1.1.2.jar</li>
			<li>abdera-i18n-1.1.2.jar</li>
			<li>abdera-parser-1.1.2.jar</li>
			<li>axiom-api-1.2.10.jar</li>
			<li>axiom-impl-1.2.10.jar</li>
			<li>commons-logging-1.0.4.jar</li>
		</ul>
	</dd>
	
	<!-- FreezeDry for serialization -->
	<dt>FreezeDry</dt>
	<dd>
		In order to send objects across the network, Diffusive must serialize them. How Diffusive serializes the objects
		is configurable. Currently Diffusive allows serialization using Java's default serialization, and alternatively
		using <a href="http://freezedried.sourceforge.net">FreezeDry</a>. Java's default approach requires that all classes 
		to be serialized implement <b class="class">Serializable</b> and have a no-arg constructor. FreezeDry is a bit 
		more flexible and requires neither of these, but is an alpha, and from time to time you may run into bugs.
		<ul>
			<li>FreezeDry_0.2.2.jar</li>
			<li>json-20120228.jar</li>
		</ul>
	</dd>
	
	<!-- Testing, Logging, Streams -->
	<dt>Logging, Unit Tests, and Streams</dt>
	<dd>
		Diffusive has a few additional dependencies for basic functions.
		<ul>
			<li>junit-4.8.1.jar</li>
			<li>log4j-1.2.15.jar</li>
			<li>commons-io-2.4.jar</li>
		</ul>
	</dd>
	
</dl>

<!-- 
	Configuring Diffusive
 -->
<h3 id="configuring_diffusive"><a href="#participate">Configuring Diffusive</a></h3>
<p>Given its current-state idiosyncrasies, configuration of Diffusive is accomplished through Java source files that are
are compiled with the build. (See <a href="#configuration_idiosyncrasy">configuration idiosyncrasy</a>.) There are two 
parts of Diffusive the must be configured: the diffuser configuration; and, the diffuser-server configuration. In the
next two subsections we describe the purpose and elements of both configurations.</p>

<p>Recall that, although all diffusers are the same, the application-attached diffuser is the diffuser to which <em>diffusive</em>
methods are dispatched. It is the application-attached diffuser that then distributes the method call to remote diffusers. To do
this, the application-attached diffuser must know which to which remote diffusers it can send methods--in other words, it must
know its end-points and its diffusion strategy. It must also know which serialization mechanism to use. And, it must be able to
supply the remote diffuser with a set of class paths from which the remote diffuser can load classes. This configuration is
covered in the next section, <a href="#default_diffuser_configuration">Default Diffuser Configuration</a></p>

<p>Recall also that to communicate with a RESTful diffuser, you must launch a diffuser server (<b class="class">RestfulDiffuserServer</b>). 
The diffuser server provides two services. It provides access to the diffusers. And, it provides access to the <b class="class">Class</b>
objects needed by the remote diffuser's class loader. The <b class="class">RestfulDiffuserServer</b> extends the
<b class="class">javax.ws.rs.core.Application</b> class and binds to the JAX-RS resources,
<b class="class">RestfulDiffuserManagerResource</b> for access to the diffusers, and the <b class="class">RestfulClassPathResource</b>
to allow remote loading of classes. When a new <b class="class">RestfulDiffuserManagerResource</b> is created, it must be handed
a default set of end-points and a strategy with which to select the end-points. We cover this configuration in the section,
<a href="#diffuser_server_configuration">Diffuser-Server Configuration</a></p> 

<!-- Default Diffuser Configuration -->
<h4 id="default_diffuser_configuration"><a href="#participate">Default Diffuser Configuration</a></h4>
  
<p>When using the <a href="javadocs/index.html?org/microtitan/diffusive/launcher/DiffusiveLauncher.html"><b class="class">DiffusiveLauncher</b></a>
directly, without extending and customizing it, the only configuration you must perform is related to the:
<ol>
	<li>Type of serialization you would like to use for the objects that are transferred over the network.</li>
	<li>Location of the remote diffusers with which you would like to interact.</li>
	<li>Class path URI that remote diffusers will look to when attempting to load a class.</li>
</ol>
<p>And all this configuration is held in the
<a href="javadocs/index.html?org/microtitan/diffusive/launcher/config/RestfulDiffuserConfig.html"><b class="class">RestfulDiffuserConfig</b></a>
class' <b class="class">configure()</b> method.</p>

<pre class="brush: java">
@DiffusiveConfiguration
public static final void configure()
{
	// 1. create the serializer
	String serializerName = SerializerFactory.SerializerType.OBJECT.getName();
	SerializerFactory factory = SerializerFactory.getInstance();
	Serializer serializer = factory.createSerializer( serializerName );

	// 2. create the diffusion strategy. this holds the end-points (location) of the
	//    remote diffusers to which annotated methods are diffused, and the strategy
	//    used to determine the end-point for a diffused call.
	DiffuserStrategy strategy = createStrategy();
	
	// 3. create a list of end-points remote diffusers will look to when attempting
	//    to load a class
	List< URI > classPaths = createClassPathList();
	
	// IMPORTANT:
	// create the diffuser and add it to the global diffuser repository. this is
	// needed because the byte-code engineering framework needs access to the 
	// diffuser so it can replace the annotated method calls.
	Diffuser diffuser = new RestfulDiffuser( serializer, strategy, classPaths, LOAD_THRESHOLD );
	KeyedDiffuserRepository.getInstance().setDiffuser( diffuser );
}
</pre>

<p>You may have noticed a set of static variables a the top of the <b class="class">RestfulDiffuserConfig</b> source file.</p>

<pre class="brush: java">
// holds the list of client endpoints to which diffused methods are sent. the end-point must
// have a restful diffusive server running that can accept requests.
public static final List< String > CLIENT_ENDPOINTS = Arrays.asList( "http://192.168.1.4:8182" );

// holds the base URI of the class path that gets passed to the remote diffuser manager 
// when creating a diffuser. this allows the remote code to load classes from a remote 
// server. This URI typically points to the host running that is launching the code to be 
// diffused (since it is that code that has the classes), or some other host that holds 
// all the required classes (that have been deployed there) and is running a restful 
// diffuser server
public static final List< String > CLASSPATH_URI = Arrays.asList( RestfulDiffuserServer.DEFAULT_SERVER_URI );

// the threshold for CPU loads, above which the diffuser will send the tasks to a 
// remote diffuser, unless of course, there are no client end-points specified. When 
// the threshold is below the load threshold, the diffuser will call the local diffuser 
// to execute the tasks.
public static final double LOAD_THRESHOLD = 0.5;
</pre>

<p>These variable provide an easy way to set the basic configuration. However, you can update this class to read
from a file, or do whatever you want. This configuration file can also be changed, and we discuss that and a few
other basic customizations in the next section.</p>

<!-- Custom Diffuser Configuration -->
<h4 id="custom_diffuser_configuration"><a href="#participate">Custom Diffuser Configuration</a></h4>
<p>In most cases the <b class="class">RestfulDiffuserConfig</b> class should provide enough flexibility. However,
more than likely you'll want to implement a configuration class that reads the configuration from a file (for
sure I have that on my ToDo list). Although you could simply modify the existing <b class="class">RestfulDiffuserConfig</b>
class, a more sensible approach is to create a new class that meets your needs, and then tell the 
<b class="class">DiffusiveLoader</b> object to use that configuration class.</p>

<p>Fortunately, this is quite straightforward. Simply create a new class <b class="class">MyDiffusiveLauncher</b> that
extends <b class="class">DiffusiveLauncher</b>. In your new launcher, create a main and use the following code.</p>

<pre class="brush: java">
public class MyDiffusiveLauncher extends DiffusiveLauncher {

	public static void main( String[] args )
	{
		// create a loader with that uses your specific configuration class and use
		// that to create a diffuser launcher
		List< String > configClasses = Arrays.asList( MyConfigClass.class.getName() );
		DiffusiveLoader loader = createLoader( configClasses );
		DiffusiveLauncher launcher = new DiffusiveLauncher( loader );

		final String classNameToRun = // the name of the your application's main class
		final String[] programArgs = // the program arguments expected by your application
		launcher.run( classNameToRun, programArgs );
	}
}
</pre>

<p>Notice that we no longer use <b class="class">DiffusiveLauncher</b>'s default, no-arg constructor. Instead,
we use the <b class="class">DiffusiveLauncher.createLoader(...)</b> method to create a new loader that uses
your new configuration class instead, and then hand that new loader to the <b class="class">DiffusiveLauncher</b>'s
constructor. The new configuration class is shown below.</p>

<pre class="brush: java">
public class MyConfigClass {

	@DiffusiveConfiguration
	public static final void configure()
	{
		// add your configuration code
		.
		.
		.
		
		// IMPORTANT: you MUST create the diffuser and add it to the repository
		// create the diffuser and add it to the global diffuser register
		Diffuser diffuser = new RestfulDiffuser( serializer, strategy, classPaths, LOAD_THRESHOLD );
		KeyedDiffuserRepository.getInstance().setDiffuser( diffuser );
	}
}
</pre>

<p>More extensive customizations, such as creating and using a new loader follow the same pattern. Clearly, the
<b class="class">DiffusiveLauncher</b> could be updated to allow that specification of the configuration class.
That would be a great contribution.</p>

<!-- Diffuser-Server Configuration -->
<h4 id="diffuser_server_configuration"><a href="#participate">Diffuser-Server Configuration</a></h4>

<p>When running the <b class="class">RestfulDiffuserServer</b> class' <b class="class">main(...)</b> method without any
command-line arguments, it uses the default configuration class, <b class="class">RestfulDiffuserServerConfig</b>. In a
manner similar to the configuration of the application-attached diffuser, the server configuration method(s) are identified
by the annotation <b class="class">@DiffusiveServerConfiguration</b>. The code below shows the default configuration 
method.</p>

<pre class="brush:java">
@DiffusiveServerConfiguration
public static final void configure()
{
	// 1. create a list of end-points that all new diffusers will have
	List< URI > clientEndpoints = // the list of end-points
	
	// 2. create the strategy by which end-ponts are selected
	DiffuserStrategy strategy = new RandomDiffuserStrategy( clientEndpoints );
	
	// 3. IMPORTANT: all configurations MUST add the strategy to the repository
	// 	  add the strategy to the diffusive-strategy repository
	KeyedDiffusiveStrategyRepository.getInstance().setValues( strategy, LOAD_THRESHOLD );
}
</pre>

<p>The customization of the the diffusive-server configuration can be accomplished by creating a new configuration
class and specifying it in as a command-line argument when launching the server.</p>

<!-- 
	Running Diffusive
 -->
<h3 id="running_diffusive"><a href="#participate">Running Diffusive</a></h3>

<p>Running Diffusive is pretty straightforward. In this section we'll walk you through running the test cases using
Eclipse IDE. In this way, you'll be set up for debugging and participating in Diffusive's development.</p>

<ol>
	<li>Fire up Eclipse on all the machines that will participate and note their IP addresses.</li>
	<li>In the <b class="class">RestfulDiffuserConfig</b> class, update the end-points to hold all
		the IP addresses <b>except</b> the box on which you will launch the application.</li>
	<li>In this example, we won't be doing any nested diffusion, so make sure that the end-points
		defined in the <b class="class">RestfulDiffuserServerConfig</b> is an empty list. This tells
		new diffusers that they will run everything locally, and won't diffuse any methods further.</li>
	<li>Perform the second step on all the machines.</li>
	<li>Run <b class="class">RestfulDiffuserServer</b> on all the machines without specifying any
		command-line arguments.</li>
	<li>Run <b class="class">DiffusiveLauncher</b> on your local box without specifying any command-line
		arguments.</li>
</ol>

<p>At this point, the code should be diffusing and your results will soon start coming back. You can adjust the logging levels
on the remote machines if you would like to see some action.</p>

</article>

</body>
</html> 
