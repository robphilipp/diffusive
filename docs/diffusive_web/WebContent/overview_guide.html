<!DOCTYPE html>
<html lang=en>
<head>
	<meta charset=utf-8>
	<link rel="stylesheet" type="text/css" href="diffusive.css"/>
    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shCore.css" />
    <link rel="stylesheet" type="text/css" href="scripts/syntax_highlight/shThemeEclipse.css" />

    <!-- Code Syntax Highlighting -->
    <script src="scripts/syntax_highlight/shCore.js"></script>
    <script src="scripts/syntax_highlight/shBrushJava.js"></script>
    <script src="scripts/syntax_highlight/shBrushXml.js"></script>

    <script src="scripts/toc-creator.js"></script>
    <script src="scripts/sizing.js"></script>

    <script src="scripts/jquery-1.8.3.js"></script>
    <script>
        var tocBounds = { minWidth: 100, maxWidth: 225, minHeight: 400, maxHeight: 750 };
        var articleBounds = { minWidth: 100, maxWidth: 775, minHeight: 400, maxHeight: 1000 };
        $(document).ready( function() {

            // syntax highlighting for the code
            SyntaxHighlighter.defaults['gutter'] = false;
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.all();

            // create the table of contents
            createToc( "Contents" );

            // adjust the article window size
            adjustSizes( tocBounds, articleBounds );
        } );

        window.onresize = function() {
            adjustSizes( tocBounds, articleBounds );
        };

    </script>

    <title>Diffusive</title>
</head>

<body>


<header>
    <img src="images/web_banner.png">
</header>

<nav>
    <a href="index.html">Home</a>
    <a href="quick_start.html">Quick Start</a>
    <a href="javadocs/index.html" target="tab">Java Docs</a>
    <a href="https://sourceforge.net/p/diffusive/code/" target="tab">Code (hg)</a>
    <a href="https://sourceforge.net/projects/diffusive/files/" target="tab">Downloads</a>
    <a href="https://sourceforge.net/p/diffusive/wiki/Home/" target="tab">Wiki</a>
    <a href="https://sourceforge.net/p/diffusive/tickets/" target="tab">Tickets</a>
    <a href="https://sourceforge.net/p/diffusive/discussion/" target="tab">Discussion</a>
</nav>

<article>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>The goal of <b>Diffusive Programming</b> is to make task-oriented distributed computing easier by separating 
the execution logic from the distribution logic. <em>Diffusive programming</em>, defined by a set of six principles, 
is an approach for performing method-level, task-oriented distributed computing. In <em>diffusive programming</em>, 
any method can be <em>marked</em> for distribution, regardless of its signature. And <em>marking</em> a method is 
necessary and sufficient for its execution to be distributed. Distribution of tasks occurs through a network of nodes 
that can accept tasks and execute them, or forward them on. Nodes executing a task, load the required resources as needed, 
and cache them. The topology of the network of nodes can be anything that can be represented as a directed graph. 
Topologies can be tailored to solve specific problems. <em>Diffusive</em> is a Java reference implementation of the 
six principles that define <em>diffusive programming</em>.</p>

<h2 id="introduction"><a href="#overview">Introduction</a></h2>
<p>Task-oriented distributed computing allows independent computational tasks to be distributed to multiple computing nodes, 
presumably to execute in parallel. This approach can reduce the overall compute time of a set of independent tasks. For 
example, in quantitative finance, one may desire to calculate risk metrics for each financial instrument contained in a 
large portfolio. When the calculation of the desired risk metrics for each instrument is independent of the calculation 
for all other instruments, the risk metrics of each instrument can be calculated independently. In this case, we can speed 
up the risk metrics calculation for the portfolio by spreading these independent tasks over many compute nodes at once, 
and then collecting the results.</p>

<p>Typically this type of distribution is performed by a distribution middleware. In many cases, the application makes calls to 
the middleware's application programming interface (API). The computational task may be represented by an object whose class 
implements an interface that represents a <em>compute task</em> as defined by the middleware. Including middleware API calls in the 
application code couples the application to the middleware. And more concerning, the application is now polluted with code used to 
distribute execution to remote compute nodes. Clearly, with careful design, much of that distribution logic can be hidden behind 
wrappers that allow the application logic to interact with an abstract compute engine, instead. And, the compute engine could be 
implemented to execute locally or remotely. But even this approach doesn't overcome the constraints imposed by the requirement 
that computational tasks implement a specific interface.</p>

<p>Distribution middleware may also require deployment of certain resources (dynamic libraries, class files, etc) to the 
compute nodes <em>before</em> they can execute remote requests. This requires careful synchronization of versioned resources. 
And this renders the compute nodes generic, only insofar as the required resources have been deployed to that node.</p>

<p><em>Diffusive programming</em> is based on a set of six principles intended to facilitate the development of task-oriented 
distributed applications. it is an approach for performing task-oriented distributed computing that allows the execution of 
individual methods to be distributed. Any method can be distributed, regardless of its signature. And aside from specifying 
that a method is to be distributed, no further code changes are required. Furthermore, <em>Diffusive programming</em> allows 
the application code to define the execution logic (i.e. the order and concurrency of the execution threads) without having 
to explicitly implement how tasks are distributed---the implementation of the <em>diffusive programming</em> principles 
manages the distribution of <em>marked</em> methods.

<p>The next section, <a href="#principles_of_diffusive_programming">Principles of Diffusive Programming</a>, provides a 
concise version of the principles and defines additional terms used throughout the rest of the paper. The subsections that 
follow the list of principles describe each principle in more detail. With the principles defined 
and explained, section <a href="#diffusion_patterns">Diffusion Patterns</a>, puts forth a few network 
topologies, or patterns, that are possible through diffusive programming. And section 
<a href="#reference_implementation">Reference Implementation</a>,  describes <em>Diffusive</em>, the Java reference 
implementation of the <em>diffusive programming principles</em>. Finally, section <a href="#future_work">Future Work</a>, 
presents future work to be done on diffusive.</p>

<!-- 

	Principles of Diffusive Programming

 -->
<h2 id="principles_of_diffusive_programming"><a href="#overview">Principles of Diffusive Programming</a></h2>
<em>Diffusive programming</em> is based on six principles that define a framework for performing task-oriented 
distributed computing. The six principles are ordered. They build on each other, progressing from the action of 
distributing the code to the deployment and configuration of the computation nodes.

<!-- 
	The Principles
 -->
<h3 id="the_principles"><a href="#overview">The Principles</a></h3>
<dl>
	<!-- marking, diffusive -->
	<dt>Marking</dt>
	<dd>
		A method can be marked for remote execution. The act of <em>marking</em>, alone, is 
		sufficient and necessary for a method to be executed on a remote location and have the results returned.
		
		<p class="definition"><em>Definition</em>: A <b>diffusive method</b> is a method that has been <em>marked</em>.</p>
	</dd>
	

	<!-- location opaquenes -->
	<dt>Location Hiding</dt>
	<dd>
		Code calling a <em>diffusive</em> method does not, and can not, know on which 
		resource that method was executed. This helps keep code <em>cohesive</em> by removing distribution logic 
		from the application. 
	
		<p class="definition"><em>Definition</em>: A <b>diffuser</b> is what executes a <em>diffusive</em> method.</p>
	
		<p class="definition"><em>Definition</em>: A <b>diffused method</b> is a <em>diffusive</em> method that was 
		executed by a <em>diffuser</em>.</p>
	</dd> 
	
	<!-- failure hiding -->
	<dt>Best-Efforts Failure Resolution</dt>
	<dd>
		A <em>diffuser</em> will attempt to recover from a 
		<em>diffusive failure</em>. If the <em>diffuser</em> is unable to recover, it will transfer error 
		handling to a specified handler or report the error as a local error.
	
		<p class="definition"><em>Definition</em>: A <b>diffusive failure</b> is a the failure of a remote 
		<em>diffuser</em> to execute a <em>diffusive</em> method, or the loss of connectivity to a remote 
		<em>diffuser</em>.</p>
		
	</dd>
	
	<!-- generic computation engine -->
	<dt>Generic Computation</dt>
	<dd>
		Any <em>diffusive</em> method can be executed by any <em>diffuser</em>. A <em>diffuser</em> need not 
		be configured with resources prior to the request to execute a method.
	</dd>
	
	<!-- indistinguishablity -->
	<dt>Indistinguishability</dt>
	<dd>
		A <em>diffuser</em> is responsible for executing any <em>diffusive</em> method, and it is also responsible 
		for <em>diffusing</em> methods to other <em>diffusers</em>. This implies that a <em>diffuser</em> must be 
		able to act both as a client and and as a server.
	</dd>
	
	<!-- open topology -->
	<dt>Open Topology</dt>
	<dd>
		<em>Diffusers</em> can be connected in any topology that can represented as a directed graph. Each node 
		in the directed graph represents a <em>diffuser</em>. Each directed edge represents a connection from one 
		<em>diffuser</em> to another. The direction of the edge represents the direction of the <em>diffusion</em>. 
		And, each <em>diffuser</em> may contains connections to a set of other <em>diffusers</em>. 
	
		<p class="definition"><em>Definition</em>: A <b>diffuser network</b> is a set of connected <em>diffusers</em>.</p>
	
		<p class="definition"><em>Definition</em>: Suppose we have two <em>diffusers</em>, <b><em>A</em></b> and <b><em>B</em></b>. We say 
		that <b><em>B</em></b> is an <b>end-point</b> of <b><em>A</em></b>, if <b><em>A</em></b> <em>diffuses</em> methods to 
		<b><em>B</em></b>.</p>
	</dd>
</dl>

The following subsections describe each principle in more detail, and where applicable, how that principle 
differs from more typical or traditional methods of distributed computing.

<!-- 
	Marking
 -->
<h3 id="marking_principle"><a href="#overview">Marking</a></h3>
<p><em>Diffusive programming</em> allows the execution of individual methods to be distributed. <em>Marking</em> a 
method is the act of specifying that a specific method is to be distributed. How a method is <em>marked</em> is 
up to the implementation of this principle. However, this principle does state that the act of <em>marking</em> a 
method is necessary and sufficient for the method to be distributed. This means that <em>any</em> method can be 
marked, and, therefore, executed, regardless of its name, parameters, or return type. This is a departure from 
many typical task-orient approaches that require the implementation of task interfaces, where the method to be 
executed has a defined signature (and return type).</p>

<p>The way a method is marked, to become a <em>diffusive</em> method, depends on the implementation of this principle. 
For example, the reference implementation written in Java currently uses annotations to mark methods. However, it 
could just as easily allow the fully qualified method names to be specified in a configuration file instead.</p>

<p>The act of marking a method decouples the distribution logic from the application logic. And this leads us to the 
next principle: location hiding.</p>

<!-- 
	Location Hiding
 -->
<h3 id="location_hiding_principle"><a href="#overview">Location Hiding</a></h3>
<p><em>Marking</em> a method tells the diffusive framework that that method is to be executed in a distributed manner. 
But it is the principle of <em>location hiding</em> that places the requirement that any code calling a diffusive method 
does not know, or need to know, where that method is executed. Removing the responsibility of knowing or having to deal 
with the consequences of where the method is executed relieves the calling code of any responsibility regarding 
distribution. And this allows the application code to remain cohesive. It also means that the same code can be called 
in a distributed manner, or to run completely locally with any change to the application logic.</p>

<p>In typical distributed systems, the distribution logic must be called directly from the application code. This may 
occur by calling low level application programming interfaces (API) such as in MPI, or writing task classes that implement 
interfaces defined by the distribution framework, and then modifying application code to deliver these tasks to the 
middleware.</p>

<p>Location hiding allows code to be endowed with its execution logic, and that execution logic is then automatically 
mirrored, but in a distributed manner, simply by marking the method(s). When this is coupled with the next principle, 
<em>generic computation</em>, we have a powerful and simple mechanism to distribute computation.</p>

<!-- 
	Best-Efforts Failure Resolution
 -->
<h3 id="failure_resolution_principle"><a href="#overview">Best-Efforts Failure Resolution</a></h3>
<p>A task that is called and executed completely within a local address space (for example, code running 
entirely in one process). may fail to return a result. The failure may occur because an input or logic error, and 
in this case, it may be possible to trap and handle the error condition. In other cases, the failure may occur 
because of an unanticipated bug\footnote{As opposed to the anticipated bug.} or because the server crashed. Under 
these conditions it may not be possible to trap and handle the error condition, and the entire application may 
crash or become unresponsive. In both scenarios, however, the fact that there was a failure is known because it due to
either the code trapping the error, or the user because the application crashed.</p>

<p>The situation may be quite different when a task is called from one address space and executed in another. 
For example, suppose the application-attached diffuser diffuses a method to a remote diffuser. Now suppose further 
that the task fails to execute because of an input or logic error. If the remote diffuser traps the error, it could 
return an error condition which is return, and again trapped by the application-attached diffuser, and handled as in 
the non-distributed case. However, suppose instead that the input or logic error isn't trapped, or if there is a 
bug that causes the task to crash, or if the server crashes, or if the network connection goes down. In this case, 
the application-attached diffuser waits for the result, but doesn't receive one. Yet, the application-attached diffuser 
doesn't know if the task is still executing, or if there was a failure.</p>

<p>The <em>best efforts failure resolution</em> principle requires that the application doesn't see a difference between 
a purely local and a distributed failure. The diffuser making the request is expected to perform its best to recover 
from a <em>diffusive failure</em>, and if it can't, then it reports the error. For example, diffusers could provide a 
status service that responds if the diffuser is running and accessible. If the requesting diffuser finds that the status 
of the remote server is down, then it diffuses the method to a different diffuser. It may attempt to send the task to a 
different diffuser a configured-number of times before giving up and reporting an error.</p>

<!-- 
	Generic Computation
 -->
<h3 id="generic_computation_principle"><a href="#overview">Generic Computation</a></h3>
<p>The principle of <em>generic computation</em> provides that any method can be executed on a <em>diffuser</em> 
without out the need to deploy the resource needed to execute that diffused method. Simply put, the shared object 
libraries or classes don't need to be deployed to the remote server prior to making the request. Each <em>diffuser</em> 
must contain a mechanism for providing resources to remote locations and for loading resources from a remote location.</p>

<p>In typical distributed computing, required resources must be deployed to the remote servers prior to requesting remote 
execution of a specific task. Diffusive programming removes this restriction by requiring that the mechanism which 
distributes the method execution also provides a capability to deliver the required resources to execute the method.</p>

<p>Note that, however, this does not prevent users from deploying resources to a common location from which they can be 
obtained at run-time. Under certain deployment scenarios, it may be desirable to have such a common location to provide a 
centralized control over the versions. But even in this case, the resources need only be deployed to the one common area.</p>

<!-- 
	Indistinguishability
 -->
<h3 id="indistinguishability_principle"><a href="#overview">Indistinguishability</a></h3>
<p>The principle of <em>indistinguishability</em> means that a <em>diffuser</em> must be able to receive requests to 
execute, and at the same time be able to <em>diffuse</em> (forward) those requests to another <em>diffuser</em>. In other 
words, there isn't such a thing as a client diffuser and a server diffuser: they are one and the same.</p>

<p>The <em>generic computation</em> principle alluded to this principle of <em>indistinguishability</em>. The generic 
computation principle states that a diffuser must be able to load resources from a remote diffusers, <b>and</b> at the 
same time must be able to provide resources to a remote diffuser.</p>

<!-- 
	Open Topology
 -->
<h3 id="open_topology_principle"><a href="#overview">Open Topology</a></h3>
<p>The <em>open topology</em> principle, coupled with the <em>indistinguishability</em> principle, requires that it is 
possible to create networks of <em>diffusers</em>, called <em>diffuser networks</em>, in any topology that can be 
represented as a directed graph. Each node in the directed graph represents a <em>diffuser</em>, and each (directed) 
edge connects that <em>diffuser</em> to an <em>end-point</em>, which is another <em>diffuser</em>. Any network that 
can be represented by a directed graph can be constructed.</p>

<p>This principle allows the construction of networks tailored to solve specific or general problems, networks that 
can naturally learn/discover an optimal configuration for performing certain types of tasks, or networks that contain 
sufficient redundancy to provide execution within required timelines. The <a href="#diffusion_patterns">diffusion patterns section</a>, 
describes a few possible network topologies (patterns) that are designed to solve specific problems.</p>


<!-- 

	Diffusion Patterns

 -->
<h2 id="diffusion_patterns"><a href="#overview">Diffusion Patterns</a></h2>
<p><em>Diffusion patterns</em> are made possible by the last three diffusive programming principles: generic computing; 
indistinguishability, and open topology. Together, these three principles make the statement that <em>diffusers</em> 
form building blocks that can be connected as directed graphs. The principle of <em>open topology</em> requires that 
a diffuser be connected to zero or more end-points to which it can diffuse execution of a method. The principle of 
<em>indistinguishability</em> states that each end-point, itself, must be a diffuser. This means that that diffuser 
itself is connected to zero or more other end-points. And, therefore, it can receive tasks as well as diffuse them. 
Finally, the principle of <em>generic computing</em> requires that a diffuser be able to receive (and send) resources 
needed to execute a task, allowing tasks to be diffused to other nodes dynamically and executed.</p>

<p>Because any diffuser network that can be represented as a directed graph is possible to construct, there are an 
infinite number of patters in which these networks can be constructed. And furthermore, their dynamic nature also 
allows the networks to evolve over time. In the next subsections I describe three illustrative patterns that solve 
specific problems.</p>

<p>Finally, it is important to emphasize that it is the <em>marking</em> principle and the <em>location hiding</em> 
principle that require the diffusive framework to provide a mechism for intercepting <em>marked</em> method calls and 
handing them to the (local) diffuser assigned to the application. It is that (local) diffuser that then takes care of 
diffusing the execution of the <em>marked</em> method to other remote diffusers for execution. Therefore, all the 
topologies have this characteristic in common.</p>

<!-- 
	Layered
 -->
<h3 id="layered"><a href="#overview">Layered</a></h3>
<p>The layered topology is the simplest, and most similar to many distributed middleware solutions. In this topology, 
the diffuser collocated with the application, which we will call the <em>application-attached diffuser</em>, is connected 
to a set of end-points, which we call the <em>remote diffusers</em>. The application-attached diffuser, depending on 
the specifics of its configuration, is responsible for distributing the tasks to the the remote diffusers. The remote 
diffusers execute the task and return the results to the application-attached diffuser, which returns the results to 
the application\footnote{In the discussion about the reference implementation, <em>Diffusive</em>, I'll provide details 
on how these steps can be implemented.}.</p> 

<h4 id="single_layered"><a href="#overview">Single Layered</a></h4>
<p>The <a href="#figure_single_layered">figure below</a> shows the simplest topology---a single layered diffuser network. In this figure, the circles label with 
<b><em>D</em></b> are <em>diffusers</em>, the square at the bottom label with <b><em>A</em></b> is the application containing 
the methods to be diffused. In this topology, the application-attached diffuser is responsible for distributing the tasks 
to the remote diffusers. The remote diffusers execute their assigned task and return the result to the application-attached 
diffuser, which then returns it to the application.</p>

<p class="image" id="figure_single_layered">
	<img src="images/topology_single_layer.png" title="Single Layer Diffuser Network Topology"/>
</p>

<p>Although not covered in the diffusive principles, because it is an implementation detail, it is worth noting at 
this point that any implementation must address the strategy used to distribute the tasks amongst the 
diffusers---local and remote. The reference implementation <em>Diffusive</em> provides a <b class="class">Strategy</b> 
interface that can be implemented to provide a specific strategy based on CPU load, number of executing threads, 
weighting, or some other scheme. Clearly, the implementation of such a strategy will effect the performance 
characteristics of the diffusive network.</p>

<h4 id="multi_layered"><a href="#overview">Multi-Layered</a></h4>
<p>A natural extension of the single-layered diffuser pattern is a multi-layered diffuser pattern. One such pattern is 
shown in the <a href="#figure_multi_layered">figure below</a>, which is effectively map-reduce. Implementations of the
diffusive principles that allow nested method <em>marking</em> allow tasks to be diffused that, themselves, contain
sub-tasks that are to be diffused. This type of topology can dramatically improve the performance of calculations
that can be represented as tasks of sub-tasks. An
illustrative example is a calculation that is composed of a set of independent calculations, where each of these 
independent calculations are themselves composed of a set of independent calculations.</p>

<p class="image" id="figure_multi_layered">
	<img src="images/topology_multi_layer.png" title="Multi-Layer Diffuser Network Topologies"/>
</p>

<p>As more concrete example, suppose that we want to calculate the expected losses due to borrower default for a large 
mortgage portfolio using a Monte Carlo simulation. The calculation of expected loss for each mortgage is independent, 
and therefore the expected loss for each mortgage can be easily distributed. Additionally, for each mortgage we want 
to calculate the loss over a large number of scenarios from which we calculate the expected loss. (Assume that 
the scenarios are generated according to some distribution, and so the expectation value is the weighted-average of the 
loss along each scenario in the distribution.) The loss for each scenario can be calculated independently, and se we 
can distribute the scenario calculations as well.</p> 

<p>We can think of this as <em>nested</em> distribution. The loss calculation for each mortgage can be thought of as a 
task. And each task is distributed to a remote location for execution. Each task, however, is composed of subtasks--the 
calculation of loss for each scenario--and these subtasks are further distributed to remote locations for execution. 
This approach is illustrated in the <a href="#figure_multi_layered">multi-layered topology figure</a>.</p>

<p>In diffusive programming, we would <em>mark</em> the methods representing the tasks, and we would also <em>mark</em> 
the methods representing the subtasks. Because the tasks are marked, they are diffused to a remote diffuser. When the 
remote diffuser executes the task, it comes across the <em>marked</em> subtasks, and therefore diffuses the subtasks 
further.</p>

<!-- 
	Redundant
 -->
<h3 id="redundant"><a href="#overview">Redundant</a></h3>
<p>In distributed computing it is not uncommon that a task fails to complete. A compute node may have crashed or 
lost network connectivity with the collective. Or some mysterious set of events placed the execution of the task 
in an unusual, never-to-be-repeated-until-a-demo state that prevented its completion. In cases where the completion 
of each individual task is required to occur at least once in a given time period, we could send redundant tasks to 
different compute nodes, and use the first result from each individual task to come back.</p>

<p>The principles of <em>generic computation</em> and <em>location hiding</em> mean the the implementation of the 
diffusive principles hides this from the application. The application configuration would be the only change to the 
application's execution. Furthermore, it turns out that this redundancy is quite straight forward to implement 
through the user of the <b class="class">Strategy</b> interface. By having the <b class="class">Strategy</b> return a 
set of endpoints, rather than a single one, the same tasks can be sent to all the end-points in a set. The first 
result to return is passed to the application, and the rest are either ignored, or cancelled.</p>

<!-- 
	Learning
 -->
<h3 id="learning"><a href="#overview">Learning</a></h3>
<p>Not all servers are created equal. For purposes of distributed computing, I focus on three important differences:</p>
<ul>
	<li>Execution capacity</li>
	<li>File input-output (I/O) capacity</li>
	<li>Network I/O capacity</li>
</ul>

<p>Execution capacity describes the available processing capacity of the server. (I am referring to a physical 
server in these examples. However, the arguments apply equally as well if the servers are virtualized, but roughly 
guarantee a certain execution capacity.) All else equal, servers with a higher processor and core count will provide 
higher execution capacity. Clearly there are many other factors that determine the execution capacity of a server. And, 
therefore, when distributing execution tasks, having information about the execution capacity of a server helps determine 
the optimal amount of work to distribute to that server relative to other servers.</p> 

<p>As an oversimplified example, suppose that you have two servers available to which tasks can be sent: server <b><em>A</em></b> 
and server <b><em>B</em></b>. If the server <b><em>A</em></b> has four processors and server <b><em>B</em></b> has only one 
processor, then if the servers are otherwise the same, you would expect  that server <b><em>A</em></b> can process about 
four times as much work as server <b><em>B</em></b>. If the tasks involve writing a large amount of data to a distributed 
data base, then it may be necessary to consider differences in the servers' file I/O or network I/O capacity when 
determining the optimal distribution of tasks.</p>

<p>To account for the differences in the capacity of a server to perform tasks, one can use a <b class="class">Strategy</b> 
that takes in to account weighting factors assigned to each server. These weighting factors would be configured to represent 
the capacity of the node to perform specific sets of tasks. And the <b class="class">Strategy</b> would select servers for 
tasks based on their weighting. For example, if server <b><em>A</em></b> had four processors and server <b><em>B</em></b> 
has only one processor, we may configure server <b><em>A</em></b>'s weight to be four, and server <b><em>B</em></b>'s 
weight to be 1. The <b classs="class">Strategy</b> would use these weights to send about for times as many tasks, on average, 
to server <b><em>A</em></b> than to the server <b><em>B</em></b>.</p>

<p>The assignment of these relative weights to each server can be automated in cases where the same type of processing is 
performed repeatedly. This type of automation can be achieved through the use of a <b class="class">Strategy</b> that 
adjusts the weights and the logs them. Once the overall execution of the process is complete, the application-attached 
diffuser makes an associate of the overall execution time (possibly scaled to the number of similar tasks) with those 
weights. The next time the process is run, <b class="class">Strategy</b> uses this information---weight-to-server 
assignments and the execution time of that combination---to again adjust the weighting factors according to some 
optimization algorithm.</p>


<!-- 

	Reference Implementation

 -->
<h2 id="reference_implementation"><a href="#overview">Reference Implementation</a></h2>
<p>The <em>Diffusive</em> reference implementation is a Java-based framework that implements the <em>diffusive</em> 
principles. Aspects of <em>Diffusive</em> are specific to its implementation, and could be implemented in other ways. 
For example, in <em>Diffusive</em> methods are <em>marked</em> through the use of annotations. In particular, a 
<em>diffusive</em> method is annotated with \textsf{@Diffusive}. However, it would have been possible to allow 
methods to be marked through a configuration file that holds a list of <em>markers</em> represented by their 
fully qualified method names. (For example, the fully qualified method name could be represented by the
fully qualified class name with the method name appended with a &quot;.&quot;, such as 
<b class="class">org.myapp.calc.PriceCalc.calculate</b>.). These aspects only change the specifics of how a
<em>diffusive</em> framework implements the principles, but not how it behaves.</p>

<p>In the next sections I discuss how <em>Diffusive</em> framework implements the five diffusive principles.</p>

<!-- 
	Marking and Diffusing
 -->
<h3 id="marking_and_diffusing"><a href="#overview">Marking and Diffusing</a></h3>
<p>The diffusive principle, <em>marking</em>, requires that a method is somehow identified as a 
<em>diffusive method</em>. It further requires that <em>marking</em> a method is both sufficient and necessary for 
a method to be diffused. The <em>location hiding</em> principle takes it a step further by requiring that any 
application method calling a diffusive (marked) method does not, and can not, know where that method is being executed.</p>

<!-- 
	Launching and Instrumentation
 -->
<h4 id="launching_and_instrumentation"><a href="#overview">Launching and Instrumenting</a></h4>
<p><em>Diffusive</em> accomplishes this through a combination of annotations and load-time byte-code engineering. 
The annotations are simple: any method that is to be diffused is annotated with <b class="class">@Diffusive</b>. This signals 
the class-loader that any calls to this method should be replaced with a call to a pre-configured diffuser. In this way, the 
marked method calls get handed to the diffuser, along with the methods parameter types and values, then name of the class in
which the method resides, and the method's return type. To accomplish this <em>Diffusive</em> uses the byte-code 
engineering framework <a href="http://www.jboss.org/javassist/">Javassist</a>. (Some have pointed out that another 
approach would have been to use aspect-oriented programming frameworks such as AspectJ. However, the compact 
<a href="http://www.jboss.org/javassist/">Javassist</a> framework provides everything <em>Diffusive</em> needs.)</p>

<p>In order to replace marked methods during class-loading, the application classes must be loaded through the diffusive 
class loader (<b class="class">DiffusiveLoader</b>). This is accomplished by using an application launcher, called the 
diffusive launcher (<b class="class">DiffusiveLauncher</b>). The diffusive launcher accepts the name of the application's 
Java class, creates a diffusive class loader, and asks it to run the application. The diffusive loader reads the 
configuration items, sets up the application-attached diffuser to which marked method calls are diverted, and determines 
whether a class is loaded by the application's class loader and which are passed to the <a href="http://www.jboss.org/javassist/">Javassist</a>
<b class="class">Loader</b>.</p>

<p class="image" id="figure_diffusive_launcher">
	<img src="images/diffusive_launcher.png" title="Launching an application in Diffusive"/>
</p>

<p>The above <a href="#figure_diffusive_launcher">figure</a> illustrates launching an application in <em>Diffusive</em>. 
At the top of the figure is a box labeled &quot;Application&quot; which represents the unadulterated application. The light 
blue dot in that box represents a method call to the red dot. The red dot represents a <em>marked</em> method. The 
application passes through the launcher and into the loader. The <b class="class">DiffusiveLoader</b> sets up the 
repository holding the default diffuser, reads the configuration items, creates an <em>application-attached</em> diffuser, 
and hands the application to the Javassist <b class="class">Loader</b> to instrument the application. The tan box labeled 
&quot;Application&quot; in the lower-right hand side of the figure represents the instrumented, or modified, application. 
Notice that now, all the method calls to the <em>marked</em> method are diverted to the <em>application-attached</em> 
diffuser, which contains the required mechanism to execute that method. It is the application-attached diffuser, the 
green circle on the bottom left-hand side of the figure, that is responsible for distributing the method execution. 
It is important to point out that the original application code is untouched.</p>

<!-- 
	Distributing
 -->
<h4 id="distributing"><a href="#overview">Distributing</a></h4>
<p>The <em>application-attached</em> diffuser is responsible for distributing method calls to other diffusers, or 
depending on its configuration and load, executing the method itself. By default <em>Diffusive</em> uses a 
<em>RESTful</em> diffuser (<b class="class">RestfulDiffuser</b>) that adheres to the <a href="http://jsr311.java.net">JSR-311</a> 
standard, and uses the <a href="http://jersey.java.net">Apache Jersey</a> implementation. Although <em>Diffusive</em> 
uses a RESTful diffuser by default, any diffuser implementation can be used to provide the required functionality. 
In fact, <em>Diffusive</em> also comes with a local diffuser that runs the code locally. (Using <em>Diffusive's</em> local 
diffuser directly is inefficient. Unless you are using the local diffuser for testing the diffusive framework through a 
local debugger, using the local diffuser directly means that you aren't diffusing the code. In which case, it doesn't 
make sense to use <em>Diffusive</em> in the first place. The local diffuser only exists because it is used by the RESTful 
diffuser when it executes a method locally rather than distribute it.)</p>

<p>The RESTful diffuser must be configured with a set of <em>end-points</em> to which it can diffuse method execution. 
These end-points, themselves, must contain a RESTful diffuser. And the access to the diffuser must be accomplished 
through a some sort of a software server. <em>Diffusive</em> provides a RESTful diffuser server 
(<b class="class">RestfulDiffuserServer</b>) that contains an <a href="http://grizzly.java.net">Apache Grizzly</a>
web server configured to interact with a <a href="http://docs.oracle.com/javaee/6/tutorial/doc/giepu.html">JAX-RS</a>. 
web resource (<b class="class">RestfulDiffuserManagerResource</b>).</p>

<p>Within the context of the RESTful diffuser server, there is one RESTful diffuser for each diffusive method. In other 
words, each unique diffusive method signature has its own diffuser, accessible via the web resource 
(<b class="class">RestfulDiffuserManagerResource</b>) through its uniform resource identifier (URI). Recall that a diffusive 
method signature contains the name of the containing class, the method name, the method's formal argument types, and the 
return type. This is different from a Java signature, which contains only the method name and the formal argument types.
The web resource manages the creation, querying, calling, and deletion of its diffusers by responding to requests from the calling diffuser. And 
each diffuser is a resource with a unique address. For example, a new diffuser is created through an <b class="tt">HTTP POST</b> 
call containing the required information about the diffusive method signature. Obtaining information about a diffuser is 
accomplished through an <b class="tt">HTTP GET</b> call to its URI. To execute a method, an <b class="tt">HTTP POST</b> is called on the URI 
of the diffuser, passing along the information needed to execute the method. The execute method returns an ID (link) to 
the results resource, in line with the approach of <em>hypermedia as the engine of application state</em> (HATEOAS). The result can then be obtained 
through an <b class="tt">HTTP GET</b> call to the URI of that result, which blocks until the result is complete. Alternatively, 
the status of the result can be obtained through an <b class="tt">HTTP HEAD</b> call to the URI of the result, which is non-blocking, 
and returns an empty response if the result resource is not yet available. And, finally, a diffuser can be deleted through 
an <b class="tt">HTTP DELETE</b> call to its URI.</p>

<p>To facilitate development, <em>Diffusive</em> provides a RESTful client (<b class="class">RestfulDiffuserManagerClient</b>) 
that takes care of the underlining communication, serializing/deserializing, creating requests, and parsing responses. This 
client allows developers to deal only with Java objects.</p>

<!-- 
	Distribution Strategy
 -->
<h4 id="distribution_strategy"><a href="#overview">Distribution Strategy</a></h4>
<p>Diffusers decide how to distribute the method calls based on a strategy (<b class="class">Strategy</b>). A 
<b class="class">Strategy</b> simply returns a list of end-points when requested. In most cases, the list returned 
by the <b class="class">Strategy</b> contains only one element. However, to allow for redundant diffuser networks, 
the <b class="class">Strategy</b> interface allows the return of a list of end-points. <b class="class">Strategy</b> 
implementations can take into account various aspects that affect the optimal distribution of method calls. For 
example, a <b class="class">Strategy</b> implementation may take into account the load on its server, the number of 
diffusers executing, the number of threads available for execution, and weighting factors for individual end-points.</p>

<!-- 
	Serialization
 -->
<h4 id="serialization"><a href="#overview">Serialization</a></h4>
<p>In order to execute a method remotely, the remote execution environment needs certain information. Specifically, 
the execution environment needs:</p>
<ul>
	<li>The state of the object against which the method call was made.</li>
	<li>All the arguments to the method.</li>
</ul>

<p>To transfer that information to the remote diffuser, across the network, they must be serialized. Likewise, once 
execution is completed, the return object must be serialized and returned to the original diffuser.</p>

<p>When the remote execution environment receives these serialized objects, it must reconstruction them as Java objects. 
And to reconstruct serialized objects requires Java <b class="class">Class</b> objects corresponding each of the 
serialized objects. The <b class="class">Class</b> objects are effectively the templates used to reconstruct an object. 
In the section on <a href="#generic_computation">generic computation</a>, we discuss how the remote environment gets 
access to these <b class="class">Class</b> objects without the need to deploy them prior to execution.</p>

<p><em>Diffusive</em> provides an interface, <b class="class">Serializer</b>, that defines what a serializer must 
provide to <em>Diffusive</em>. Two key serialization implementations have been wrapped to conform to the 
<b class="class">Serializer</b> interface: <b class="class">ObjectSerializer</b> and 
<b class="class">PersistenceSerializer</b>. The <b class="class">ObjectSerializer</b> is Java's own serialization 
framework which requires that classes implement the <b class="class">Serializable</b> interface. Using this 
serialization framework requires altering existing classes, that are to be serialized, if they don't implement 
<b class="class">Serializable</b>. In some cases this may be acceptable. In other cases it may not be possible.</p>

<p>The <b class="class">PersistenceSerializer</b> wraps the <a href="http://freezedried.sourceforge.net">FreezeDry</a> 
persistence framework. <b>FreezeDry</b> does not require any classes to implement a FreezeDry-specific interface. 
In fact, FreezeDry can take any existing class (even those without no-arg constructors) and serialize them into XML, 
JSON, or key-value pairs. However, if the class is too complex, it may require some coding.</p>

<!-- 
	Best-Efforts Failure Resolution
 -->
<h3 id="best_efforts_failure_resolution"><a href="#overview">Best-Efforts Failure Resolution</a></h3>
<p>The <em>Diffusive</em> reference implementation uses the concept of a <b class="class">Strategy</b> to determine 
to which diffuser a method is diffused. The current <b class="class">Strategy</b> interface requires that a 
<b class="class">Strategy</b> return a list of end-points to which the method can be diffused. An implementation of 
best-efforts failure resolution can be achieved by creating a RESTful diffuser that diffuses its method to the first 
end-point in the list, and if that fails to the next end-point, until the task completes, or until the diffuser runs 
out of end-points.</p>

<!-- 
	Best-Efforts Failure Resolution
 -->
<h3 id="generic_computation"><a href="#overview">Generic Computation</a></h3>
<p>The <em>Generic Computation</em> principle requires two that two conditions are met: that any method can be diffused; 
and, prior deployment of resources is not required. The first condition is met because of the <em>Marking</em> 
principle---any marked method can be diffused. The second condition is the focus of this section.</p>

<p>As discussed in <a href="#serialization">serialization section</a>, in order to transport objects across the network 
they must be serialized. This means that to execute a diffusive method remotely requires that the following objects 
must be serialized:</p>
<ul>
	<li>The object containing the diffusive method.</li>
	<li>All objects referenced by the object containing the diffusive method.</li>
	<li>The objects passed to the diffusive method as arguments.</li>
	<li>All objects referenced by the objects passed to the diffusive method as arguments.</li>
</ul>

<p>Once these serialized objects are received by the remote diffuser, it needs to deserialize them back into objects. 
To deserialize any object requires that the class loader has loaded a <b class="class">Class</b> object corresponding 
to that object (and any objects that object references). Usually, this is handled by deploying the class files 
(as jar or war files) to the remote servers executing the methods, and configuring their class paths to contain their 
location.</p>

<p>The <em>Generic Computation</em> principle states that deployment of resources to the remote nodes does not need 
to occur <em>before</em> requesting the remote diffuser to execute a method. In practical terms, this principle 
requires that the remote diffuser contains a mechanism for loading classes from a remote source, and that a mechanism 
exists, preferably on the application-attached diffuser, that can provide serialized <b class="class">Class</b> objects 
to the remote diffuser.</p> 

<p><em>Diffusive</em> provides a RESTful class loader (<b class="class">RestfulClassLoader</b>) that can load classes 
from a corresponding RESTful web service. The <b class="class">RestfulClassPathResource</b> is a (JSR-311) web resource, 
attached to the web service, that provides serialized <b class="class">Class</b> objects to the requesting client (i.e. the 
<b class="class">RestfulClassLoader</b>).</p> 

<p class="image" id="figure_diffusing">
	<img src="images/diffusing.png" title="Process of diffusing a method call"/>
</p>

<p>The above <a href="#diffusing">figure</a> shows the process of creating, configuring, and executing a task using 
<em>Diffusive</em>. In this figure, the application requests that its <em>application-attached</em> diffuser, which 
is labeled as <b>Diffuser 1</b> in the figure, execute the task labeled <b class="class">Task</b>. In this scenario,
<b>Diffuser 1</b> decides to diffuse the task to one of its end-points, <b>Remote Server A</b>. If the remote server 
doesn't contain a diffuser that matches the diffusive method signature of <b class="class">Task</b>, then, as shown in 
step 1 of the above <a href="#diffusing">figure</a>, <b>Diffuser 1</b> requests that <b>Remote Server A</b> create a diffuser 
with that signature, which is shown as <b>Diffuser 2</b>. In order to execute <b class="class">Task</b>, 
<b>Diffuser 2</b> needs to load the <b class="class">Class</b> objects associated with <b class="class">Task</b>. 
And because <b>Diffuser 1</b> has those <b class="class">Class</b> objects, it passes the URI corresponding to the 
web service that can provide those <b class="class">Class</b> objects, along with its request to create 
<b>Diffuser 2</b>.</p>

<p>As shown in step 2 of the above <a href="#diffusing">figure</a>, <b>Remote Server A</b> then creates <b>Diffuser 2</b> 
and configures it with the class path information and other configuration items, and returns URI to <b>Diffuser 2</b>, 
the newly created diffuser. <b>Diffuser 1</b> now requests that <b>Diffuser 2</b> execute <b class="class">Task</b> 
(step 3). As part of that request, <b>Diffuser 1</b> passes all the required serialized object along with the execute 
request. <b>Diffuser 2</b> receives that request, tries to deserialize the objects, but can't because it doesn't have 
access to the <b class="class">Class</b> objects associated with <b class="class">Task</b>. And so <b>Diffuser 2</b> 
initiates a call back to the class path URI requesting the <b class="class">Class</b> objects (step 4).</p>

<p><b>Diffuser 1</b> sends the serialized <b class="class">Class</b> objects requested back to <b>Diffuser 2</b> 
(step 5), and <b>Diffuser 2</b> loads the <b class="class">Class</b> objects, which enables it to deserialized the 
objects associated with <b class="class">Task</b>. Now <b>Diffuser 2</b> is set up to execute the <b class="class">Task</b>, w
hich it does (step 6), and returns a result ID. The result ID is a URI to the result. When <b>Diffuser 1</b> receives 
the result ID, it requests the result (step 7), which is a blocking call, and waits for the result response (step 8). 
When <b>Diffuser 1</b> receives the results, it deserialized the result object and returns it the application (again, 
this is automatic through Javassist).</p>

<p>There are a few noteworthy points.</p>
<ul>
	<li>Once a diffuser is created, it can be reused, and it can be deleted.</li>
	<li>The remote class loading is managed through a RESTful class loader and web service, and is part of
		<em>Diffusive</em> by default.
	</li>
	<li>When creating a remote diffuser, the class path URI does <em>not</em> need to be the URI pointing 
		back to the diffuser requesting the creating. In fact, it can be a common web service that contains a 
		pre-deployed set of class files and can serve them up. However, this reduces the generic computation 
		somewhat.
	</li>
</ul> 

<!-- 
	Indistinguishability and Open Topology
 -->
<h3 id="indistinguishability_and_open_topology"><a href="#overview">Indistinguishability and Open Topology</a></h3>
<p>In <em>Diffusive</em> all diffusers of a certain type are the same. And with the exception of the 
<em>application-attached</em> diffuser, all diffusers are managed the same way. The application-attached diffuser, 
as the name implies, is attached to the application through the diffusive launcher. Recall that the diffuser launcher 
is used to launch the application, and during the process of launching the application, the application is 
instrumented to divert calls to diffusive methods to the application-attached diffuser. It is the application-attached 
diffuser that diffuses (distributes) method calls to remote diffusers.</p>

<p class="image" id="figure_restful_diffuser_server">
	<img src="images/restful_diffuser_server.png" title="RESTful Diffuser Server"/>
</p>

<p>Recall that in <em>Diffusive</em>, a remote diffuser is managed by RESTful diffuser server. A RESTful diffuser 
servers (<b class="class">RestfulDiffuserServer</b>) act as servers to which methods can be diffused. The RESTful 
diffuser servers also act as clients when diffusing methods to other remote diffusers, or when other diffusers 
request <b class="class">Class</b> objects from their class path. And therefore, all remote diffusers look alike. 
The above <a href="#restful_diffuser_server">figure</a> shows the basic elements contained in a RESTful diffuser 
server and depicts a typical interaction. In this scenario, the <b class="class">RestfulDiffuserServer</b> receives 
a request to execute a method (task). The <b class="class">RestfulDiffuserServer</b>, a web server, forwards the 
request to the web resource, <b class="class">RestfulDiffuserManagerResource</b>, (A JSR-311 web resource)
which is bound to its <b class="class">execute(...)</b> method. The execute method looks up the appropriate diffuser 
based on the diffuser method signature, which is part of the its URI, returns a response containing the result ID 
(a URI to the result resource) and then forwards the method to that diffuser.</p> 

<p>Each RESTful diffuser contains a <b class="class">RestfulClassLoader</b> which loads a class using a RESTful web 
service. The <b class="class">RestfulClassLoader</b> acts as a client to the <b class="class">RestfulClassPathResource</b>, 
which serializes the request <b class="class">Class</b> object and returns it. The RESTful class loader then 
deserializes the <b class="class">Class</b> object and loads it. Notice that each <b class="class">RestfulDiffuserServer</b> 
contains the <b class="class">RestfulClassPathResource</b>.</p>

<p>At this point, the diffuser can execute the method and return the result to the 
<b class="class">RestfulDiffuserManagerResource</b>.</p>

<p>Each diffuser contains a list of end-points to which it can diffuse code, a list of class paths from which it can 
load <b class="class">Class</b> objects, a <b class="class">Strategy</b> which determines how the end-points for 
executing the next task are selected, and a RESTful class loader to load class over the network. It is the fact that 
each diffuser server looks the same that makes each diffuser server a building block from which to construct arbitrary 
diffuser networks---as long as they can be represented by a directed graph.</p>

<!--

	Future Work

 -->
<h2 id="future_work"><a href="#overview">Future Work</a></h2>
<p>The current reference implementation is a work in progress. The main goal for creating a reference implementation 
was to prove that the concepts of \emph{diffusive programming} could be implemented, with an eye toward building a 
robust, secure, and accessible implementation. Given that, there are a number of items that need further exploration 
and development.</p>

<ul>
	<li>Add best-efforts failure resolution to the RESTful diffuser.</li>
	<li>Provide additional deployment options (for example, into a servlet container).</li>
	<li>Create additional diffusers beside RESTful diffusers (for example, RMI diffusers).</li>
	<li>Create deployment and management tools that allow easy deployment of diffusive servers and allows starting 
		and stopping the diffusive server. Also, allows the management of the diffusers.</li>
</ul>

</article>

</body>
</html> 
